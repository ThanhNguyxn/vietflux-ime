{"$message_type":"diagnostic","message":"cannot find value `CHAR_MAP` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\transform.rs","byte_start":8743,"byte_end":8751,"line_start":272,"line_end":272,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    CHAR_MAP.get(&(base, modifier, tone)).copied()","highlight_start":5,"highlight_end":13}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this static","code":null,"level":"help","spans":[{"file_name":"src\\transform.rs","byte_start":297,"byte_end":297,"line_start":10,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::chars::{self, ToneMark, VowelMod, REVERSE_MAP};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::chars::CHAR_MAP;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `CHAR_MAP` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\transform.rs:272:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m272\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     CHAR_MAP.get(&(base, modifier, tone)).copied()\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this static\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m10\u001b[0m \u001b[92m+ use crate::chars::CHAR_MAP;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CHAR_MAP` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\transform.rs","byte_start":10924,"byte_end":10932,"line_start":333,"line_end":333,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"    if let Some(without_mod) = CHAR_MAP.get(&(base, VowelMod::None, tone)).copied() {","highlight_start":32,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this static","code":null,"level":"help","spans":[{"file_name":"src\\transform.rs","byte_start":297,"byte_end":297,"line_start":10,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::chars::{self, ToneMark, VowelMod, REVERSE_MAP};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::chars::CHAR_MAP;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `CHAR_MAP` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\transform.rs:333:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m333\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     if let Some(without_mod) = CHAR_MAP.get(&(base, VowelMod::None, tone)).copied() {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this static\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m10\u001b[0m \u001b[92m+ use crate::chars::CHAR_MAP;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `VowelMod`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src\\validation.rs","byte_start":7128,"byte_end":7136,"line_start":218,"line_end":218,"column_start":28,"column_end":36,"is_primary":true,"text":[{"text":"            if modifier != VowelMod::None || tone != crate::chars::ToneMark::None {","highlight_start":28,"highlight_end":36}],"label":"use of undeclared type `VowelMod`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"src\\validation.rs","byte_start":172,"byte_end":172,"line_start":6,"line_end":6,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::chars::{self, REVERSE_MAP};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::chars::VowelMod;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of undeclared type `VowelMod`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\validation.rs:218:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m218\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if modifier != VowelMod::None || tone != crate::chars::ToneMark::None {\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of undeclared type `VowelMod`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m6\u001b[0m \u001b[92m+ use crate::chars::VowelMod;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unexpected `cfg` condition value: `console_error_panic_hook`","code":{"code":"unexpected_cfgs","explanation":null},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":2711,"byte_end":2747,"line_start":108,"line_end":108,"column_start":11,"column_end":47,"is_primary":true,"text":[{"text":"    #[cfg(feature = \"console_error_panic_hook\")]","highlight_start":11,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"no expected values for `feature`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider adding `console_error_panic_hook` as a feature in `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`-D unexpected-cfgs` implied by `-D warnings`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"to override `-D warnings` add `#[allow(unexpected_cfgs)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"remove the condition","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":2711,"byte_end":2747,"line_start":108,"line_end":108,"column_start":11,"column_end":47,"is_primary":true,"text":[{"text":"    #[cfg(feature = \"console_error_panic_hook\")]","highlight_start":11,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: unexpected `cfg` condition value: `console_error_panic_hook`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:108:11\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m108\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[cfg(feature = \"console_error_panic_hook\")]\n    \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: remove the condition\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: no expected values for `feature`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider adding `console_error_panic_hook` as a feature in `Cargo.toml`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `-D unexpected-cfgs` implied by `-D warnings`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: to override `-D warnings` add `#[allow(unexpected_cfgs)]`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\transform.rs","byte_start":11037,"byte_end":11048,"line_start":335,"line_end":335,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"            without_mod.to_ascii_uppercase()","highlight_start":13,"highlight_end":24}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\transform.rs:335:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m335\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             without_mod.to_ascii_uppercase()\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 5 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0425, E0433.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0282, E0425, E0433.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}
